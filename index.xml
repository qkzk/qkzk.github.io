<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>accueil on qkzk</title>
    <link>http://qkzk.github.io/</link>
    <description>Recent content in accueil on qkzk</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 01 Jul 2016 12:14:12 +0000</lastBuildDate><atom:link href="http://qkzk.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Résumé</title>
      <link>http://qkzk.github.io/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://qkzk.github.io/</guid>
      <description>pdf:pour impression Récursivité Définition La récursivité est une démarche qui fait référence à l&amp;rsquo;objet même de la démarche à un moment du processus. En d&amp;rsquo;autres termes, c&amp;rsquo;est une démarche dont la description mène à la répétition d&amp;rsquo;une même règle. Par exemple :
 écrire un algorithme qui s&amp;rsquo;invoque lui-même ; définir une structure à partir de l&amp;rsquo;une au moins de ses sous-structures.  Algorithmes récursifs Exemple \ Ne faisons pas dans l&amp;rsquo;originalité :</description>
    </item>
    
    <item>
      <title>Arbres binaires - 2e partie</title>
      <link>http://qkzk.github.io/uploads/docnsitale/arbres/travaux/arbre2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://qkzk.github.io/uploads/docnsitale/arbres/travaux/arbre2/</guid>
      <description>Un module de manipulation d&amp;rsquo;arbres binaires graph LR alert(Ressource) style alert fill:orange La classe BinaryTree, définie dans le module binary_tree.py proposé ici, permet de représenter des arbres binaires.
Cette classe fournit
 « deux » constructeurs : BinaryTree() et BinaryTree(data, left, right) trois accesseurs : get_data(), get_left_subtree(), et get_right_subtree() un reconnaisseur : is_empty()  Essayez
import binary_tree as bt help(bt.BinaryTree) pour afficher l&amp;rsquo;aide associée à cette classe.
Ou utilisez le notebook Jupyter</description>
    </item>
    
    <item>
      <title>NSI - Terminale</title>
      <link>http://qkzk.github.io/uploads/docnsitale/bdd/bdd_td/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://qkzk.github.io/uploads/docnsitale/bdd/bdd_td/</guid>
      <description>Compétence : Savoir analyser un modèle Entités/Associations
Exercice 1 On souhaite gérer des réservations dans une compagnie d&amp;rsquo;hôtels.
On considère donc le modèle Entités/Associations suivant :
À l&amp;rsquo;aide de ce modèle, répondre aux questions suivantes :
 Peut-on avoir des clients homonymes ? Un client peut-il réserver plusieurs chambres à une date donnée ? Est-il possible de réserver une chambre sur plusieurs jours ? Peut-on savoir si une chambre est libre à une date donnée ?</description>
    </item>
    
    <item>
      <title>NSI - Terminale</title>
      <link>http://qkzk.github.io/uploads/docnsitale/bdd/sql_td/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://qkzk.github.io/uploads/docnsitale/bdd/sql_td/</guid>
      <description>Pour tous les exercices qui suivent on utilisera la base de données ci-dessous.
Elle est constituées de quatre relations :
Relation Stations
   NomStation Capacite Lieu Region Tarif     Tanger 350 Maroc Afrique 1200   La Bourboule 250 Auvergne Afrique 700   Victoria 200 Seychelles Océan Indient 1500   Courchevel 400 Alpes Europe 2200    Relation Activités
   NomStation Libelle Prix     La Bourboule Pêche 50   La Bourboule Randonnée 0   Tanger Plongée 120   Tanger Excursion 60   Victoria Plongée 130   Courchevel Ski 120    Relation Clients</description>
    </item>
    
    <item>
      <title>NSI Terminale - Données</title>
      <link>http://qkzk.github.io/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://qkzk.github.io/</guid>
      <description>Introduction à la programmation objet Jusqu&amp;rsquo;ici les programmes que nous avons écrits utilisaient une approche procédurale :
 On définit les variables qui représentent ce qu&amp;rsquo;on souhaite modéliser On crée les fonctions qui vont changer l&amp;rsquo;état de ces variables L&amp;rsquo;exécution coordonnée de ces fonctions fait passer nos variables d&amp;rsquo;un état à l&amp;rsquo;autre.  Cette approche permet de résoudre tous les problèmes informatiques. On peut tout programmer de cette manière.
Néanmoins elle présente un défaut majeur : il est difficile de dégager une structure à notre code.</description>
    </item>
    
  </channel>
</rss>
