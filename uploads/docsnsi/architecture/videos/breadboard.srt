1
00:00:00,000 --> 00:00:00,030
 Youtube subtitles download by mo.dbxdb.com 

2
00:00:00,030 --> 00:00:05,280
 ok donc je suis ce programme compilé de 

3
00:00:02,280 --> 00:00:08,759
 exécuter un nouveau compilateur C sur mon sur mon 

4
00:00:05,759 --> 00:00:11,730
 macbook et cela ce langage d'assemblage 

5
00:00:08,730 --> 00:00:13,400
 travaillera sur mon macbook mais il ne sera pas 

6
00:00:11,400 --> 00:00:14,048
 travaille sur cet ordinateur que j'ai construit 

7
00:00:13,048 --> 00:00:16,759
 parce que cet ordinateur a son propre 

8
00:00:14,759 --> 00:00:19,529
 langage d' assemblage que je sorte de 

9
00:00:16,529 --> 00:00:21,500
 inventé et donc ce que nous aurions besoin de faire 

10
00:00:19,500 --> 00:00:23,359
 est nous aurions besoin de trouver un compilateur AC 

11
00:00:21,359 --> 00:00:26,609
 ce serait compiler ce programme pour cette 

12
00:00:23,609 --> 00:00:28,160
 ordinateur mais depuis que je n'ai pas écrit un 

13
00:00:26,160 --> 00:00:31,439
 il n'existe pas à la place ce que nous pouvons 

14
00:00:28,439 --> 00:00:33,500
 faire est en fait une sorte de manuscrit de la 

15
00:00:31,500 --> 00:00:34,210
 programme de langage d' assemblage nous-mêmes et 

16
00:00:33,210 --> 00:00:37,680
 c'est ce que j'ai fait ici et ainsi 

17
00:00:34,680 --> 00:00:39,170
 ce programme est est fondamentalement la 

18
00:00:37,170 --> 00:00:41,899
 même chose que cela, mais il est écrit dans 

19
00:00:39,899 --> 00:00:44,489
 le langage d' assemblage pour cela 

20
00:00:41,489 --> 00:00:48,100
 ordinateur et donc si nous voulons genre de 

21
00:00:44,100 --> 00:00:49,120
 il suffit de regarder très rapidement zoomer dans un 

22
00:00:48,120 --> 00:00:52,739
 un peu ici nous aider à voir ce qui se passe 

23
00:00:49,739 --> 00:00:55,320
 sur mais si nous regardons notre programme C 

24
00:00:52,320 --> 00:00:57,710
 encore une fois au fond ce que nous faisons ici 

25
00:00:55,710 --> 00:00:59,329
 ces deux premières lignes est que x est égal à 

26
00:00:57,329 --> 00:01:00,039
 zéro en fait, nous faisons le y est égal 

27
00:00:59,039 --> 00:01:02,210
 zéro ici il y a un peu d'un 

28
00:01:00,210 --> 00:01:05,399
 optimisation que je devais faire parce que 

29
00:01:02,399 --> 00:01:06,640
 la mémoire sur ce programme est-ce 

30
00:01:05,640 --> 00:01:08,869
 sont les étudiants sur cet ordinateur et 

31
00:01:06,869 --> 00:01:10,430
 cet ordinateur n'a que 16 octets de 

32
00:01:08,430 --> 00:01:12,229
 la mémoire qui n'est pas beaucoup de mémoire à 

33
00:01:10,229 --> 00:01:15,720
 tous et donc parce que nous avions besoin de trois octets 

34
00:01:12,720 --> 00:01:20,209
 laissé ici à la fin pour la 

35
00:01:15,209 --> 00:01:21,459
 les variables XY et ZI devaient faire un peu 

36
00:01:20,459 --> 00:01:23,930
 peu d'optimisation ici pour faire la 

37
00:01:21,930 --> 00:01:25,520
 reste du programme en forme et donc le premier 

38
00:01:23,520 --> 00:01:28,920
 deux lignes est mis y égal à égal à 

39
00:01:25,920 --> 00:01:30,229
 on me laisse juste rayer cela c'est y 

40
00:01:28,229 --> 00:01:31,150
 est égal à un est ce que cela fait il est 

41
00:01:30,150 --> 00:01:33,560
 chargement d' un dans le registre et 

42
00:01:31,560 --> 00:01:37,810
 c'est stocker dans le e qui est y 

43
00:01:33,810 --> 00:01:40,259
 en emplacement de mémoire pour e qui est y et 

44
00:01:37,259 --> 00:01:42,500
 alors c'est c'est en quelque sorte le x est égal à 

45
00:01:40,500 --> 00:01:44,569
 est égal à 0 parce que si nous ne sommes pas vraiment 

46
00:01:42,569 --> 00:01:46,520
 sauver et c'est juste genre de sauvé 

47
00:01:44,520 --> 00:01:49,979
 moi cette ligne de code donc c'est une sorte 

48
00:01:46,979 --> 00:01:51,619
 de x est égal à 0, puis nous sortons de telle sorte que 

49
00:01:49,619 --> 00:01:52,360
 donc nous faisons genre de ces un peu 

50
00:01:51,360 --> 00:01:55,590
 peu hors d'usage mais peu importe 

51
00:01:52,590 --> 00:01:58,259
 et puis le printf est en quelque sorte ma sortie 

52
00:01:55,259 --> 00:02:02,709
 ici et ensuite nous faisons l'addition et nous sommes 

53
00:01:58,709 --> 00:02:04,159
 ajoutant voyons nous ajoutons e donc nous sommes 

54
00:02:02,159 --> 00:02:07,890
 ajouter Y à X pour que X soit dans le registre 

55
00:02:04,890 --> 00:02:09,468
 nous ajoutons Y donc c'est gentil de votre part 

56
00:02:07,468 --> 00:02:12,000
 peut penser à cette ligne comme étant le Z 

57
00:02:09,000 --> 00:02:13,900
 bien cette ligne ici en fait ces deux 

58
00:02:12,900 --> 00:02:16,860
 lignes 

59
00:02:13,860 --> 00:02:19,710
 sont le Z est égal à X plus y parce que cela 

60
00:02:16,710 --> 00:02:21,020
 stocker un stocke le résultat de 

61
00:02:19,020 --> 00:02:23,690
 ceci en F qui est l'adresse emplacement F est 

62
00:02:21,690 --> 00:02:26,840
 Z en est ainsi Z est égal à X plus Y et 

63
00:02:23,840 --> 00:02:30,940
 alors ces deux lignes sont ici le x 

64
00:02:26,940 --> 00:02:34,990
 est égal à y parce que nous chargeons d'un 

65
00:02:30,990 --> 00:02:37,259
 puis en stockant à D so e à D est Y à 

66
00:02:34,259 --> 00:02:40,470
 X donc x est égal à y et puis ici nous sommes 

67
00:02:37,470 --> 00:02:43,860
 faire le y est égal à Z et est le même 

68
00:02:40,860 --> 00:02:48,709
 chose que nous allons de F de F est Z et 

69
00:02:43,709 --> 00:02:52,539
 adresse a est la variable Y, puis à la 

70
00:02:48,539 --> 00:02:54,289
 finissons ici, nous nous chargeons à nouveau et c'est 

71
00:02:52,289 --> 00:02:56,989
 juste si ou nous chargeons la valeur de x dans 

72
00:02:54,989 --> 00:02:59,669
 le registre et c'est de cette façon quand 

73
00:02:56,669 --> 00:03:00,069
 nous rebouclage nous affichons la valeur de x 

74
00:02:59,069 --> 00:03:02,959
 et c’est gentil de nouveau ce genre de 

75
00:03:00,959 --> 00:03:05,870
 optimisation j'ai fait aussi 

76
00:03:02,870 --> 00:03:06,099
 plutôt que de le stocker ici et ensuite 

77
00:03:05,099 --> 00:03:10,479
 le charger à nouveau cela prendrait deux 

78
00:03:06,479 --> 00:03:12,919
 des octets supplémentaires c'est donc ici et 

79
00:03:10,919 --> 00:03:14,750
 alors le saut porter donc ce que c'est 

80
00:03:12,750 --> 00:03:17,819
 dire est que si le résultat de la dernière 

81
00:03:14,819 --> 00:03:20,910
 Outre qui est ici eu un eu 

82
00:03:17,910 --> 00:03:23,880
 transporter peu qui signifie que vous le savez 

83
00:03:20,880 --> 00:03:26,220
 est un ordinateur 8 bits donc si le résultat de 

84
00:03:23,220 --> 00:03:27,549
 cet ajout a été pris neuf bits et 

85
00:03:26,549 --> 00:03:29,750
 vous savez parce qu'un bit devait être 

86
00:03:27,750 --> 00:03:32,459
 porté puis aller vers le haut et c'est 

87
00:03:29,459 --> 00:03:37,789
 sorte de moyen de détecter si X est 

88
00:03:32,789 --> 00:03:39,019
 supérieur à 255 parce que s'il 

89
00:03:37,019 --> 00:03:41,389
 porté dans un bit 9 alors vous savez 

90
00:03:39,389 --> 00:03:43,009
 quelque chose qui vous prend pas plus de 8 

91
00:03:41,009 --> 00:03:45,470
 bits pour stocker va être plus grand 

92
00:03:43,470 --> 00:03:48,989
 que 255 alors si tel est le cas puis sautez 

93
00:03:45,989 --> 00:03:49,030
 tout le chemin à l' adresse 0 qui ensuite 

94
00:03:48,030 --> 00:03:52,889
 réinitialise le y est égal à 0 x est égal à 0 

95
00:03:49,889 --> 00:03:54,590
 sinon il tombe ici et nous sautons 

96
00:03:52,590 --> 00:03:57,720
 nous sautons seulement à l' adresse 3 qui est 

97
00:03:54,720 --> 00:04:00,120
 la sortie pour revenir encore à la 

98
00:03:57,120 --> 00:04:03,330
 printf afin que vous puissiez voir ce programme 

99
00:04:00,330 --> 00:04:05,209
 est fondamentalement une assemblée autre 

100
00:04:03,209 --> 00:04:07,940
 assemblage d'une autre compilation je suppose 

101
00:04:05,940 --> 00:04:10,069
 si vous voulez penser de cette façon 

102
00:04:07,069 --> 00:04:13,500
 nous avons compilé ce programme C mais 

103
00:04:10,500 --> 00:04:15,410
 à la place, nous avons compilé pour cela cette 

104
00:04:13,410 --> 00:04:17,479
 ordinateur construit à la maison ici maintenant la prochaine 

105
00:04:15,479 --> 00:04:20,459
 pas maintenant que nous avons cette assemblée 

106
00:04:17,459 --> 00:04:23,190
 la langue est-il de convertir cela en un 

107
00:04:20,190 --> 00:04:27,220
 au code de la machine et je l' ai donc fait que 

108
00:04:23,220 --> 00:04:30,540
 ici et faites-le glisser sur vous pouvez voir 

109
00:04:27,540 --> 00:04:31,269
 tout et donc ce que j'ai fait ici est 

110
00:04:30,269 --> 00:04:33,620
 est-ce le même programme que nous venons de 

111
00:04:31,620 --> 00:04:35,810
 a traversé et ce que je l' ai fait est 

112
00:04:33,810 --> 00:04:38,430
 vient de tout convertir en binaire 

113
00:04:35,430 --> 00:04:39,250
 parce que quand on programme l'ordinateur 

114
00:04:38,250 --> 00:04:40,509
 nous allons utiliser ces commutateurs 

115
00:04:39,509 --> 00:04:42,829
 et nous devons entrer ces choses dans 

116
00:04:40,829 --> 00:04:44,870
 binaire sur ces commutateurs juste très 

117
00:04:42,870 --> 00:04:47,579
 encombrant mais heureusement c'est un court 

118
00:04:44,579 --> 00:04:51,940
 programme et donc en gros les adresses 

119
00:04:47,940 --> 00:04:54,630
 voici seulement 0 à C hexadécimal 

120
00:04:51,630 --> 00:04:57,870
 qui est 0 à 1 1 0 0 en binaire et 

121
00:04:54,870 --> 00:04:59,089
 alors chacun de ces codes op ici chacun de 

122
00:04:57,089 --> 00:05:01,120
 ces instructions ont une correspondance 

123
00:04:59,120 --> 00:05:03,380
 Valeur binaire 4 bits et donc je viens 

124
00:05:01,380 --> 00:05:05,660
 ceux substitués ici et puis plus 

125
00:05:03,660 --> 00:05:07,940
 de ces instructions ont une sorte de 

126
00:05:05,940 --> 00:05:09,829
 paramètre qui va avec eux, puis 

127
00:05:07,829 --> 00:05:11,300
 qui vient juste d'être converti en binaire 

128
00:05:09,300 --> 00:05:14,370
 ici et c'est donc ce qui va 

129
00:05:11,370 --> 00:05:15,100
 avant et entrez et vous venez juste genre de 

130
00:05:14,100 --> 00:05:20,899
 glisser ce sur un peu afin que nous puissions 

131
00:05:15,899 --> 00:05:28,550
 l'obtenir juste à côté d'ici et zoomer afin 

132
00:05:20,550 --> 00:05:29,259
 nous pouvons voir ce qui se passe à l'intérieur d'un 

133
00:05:28,259 --> 00:05:32,490
 programmer ce que je vais arrêter l'horloge 

134
00:05:29,490 --> 00:05:33,009
 réel rapidement et vient tout effacer 

135
00:05:32,009 --> 00:05:36,779
 hors de l'ordinateur , puis nous 

136
00:05:33,779 --> 00:05:38,870
 passer en mode de programmation et 

137
00:05:36,870 --> 00:05:40,759
 donc en mode de programmation ce que je peux faire est 

138
00:05:38,759 --> 00:05:43,740
 Je peux définir l' adresse alors c'est tout 

139
00:05:40,740 --> 00:05:45,050
 zéros et puis je peux définir ici la 

140
00:05:43,050 --> 00:05:48,899
 données que je veux programmer afin 1 1 1 

141
00:05:45,899 --> 00:05:51,990
 0 0 0 1 et puis une fois que j'ai 

142
00:05:48,990 --> 00:05:54,449
 programme dentaire suffit d'appuyer sur ce bouton pour 

143
00:05:51,449 --> 00:05:56,329
 programme et je peux passer à la 

144
00:05:54,329 --> 00:05:59,970
 valeur suivante si c'est l'emplacement de la mémoire 1 

145
00:05:56,970 --> 00:06:08,940
 et ça va être éteindre tous ceux 

146
00:05:59,940 --> 00:06:10,850
 va être 0 1 0 0 1 1 1 0 et je peux 

147
00:06:08,850 --> 00:06:13,649
 programmer et je vais aller de l'avant et 

148
00:06:10,649 --> 00:06:15,500
 programmer le reste de ceci et à travers le 

149
00:06:13,500 --> 00:06:18,600
 magie du montage vidéo, nous pouvons accélérer cette 

150
00:06:15,600 --> 00:06:18,940
 pour toi 

151
00:06:23,940 --> 00:06:26,100
 vous 

152
00:06:31,100 --> 00:06:37,560
 et là nous allons donc je pense que nous sommes tous 

153
00:06:34,560 --> 00:06:40,649
 programmé ici pour que nous puissions aller de l' avant et 

154
00:06:37,649 --> 00:06:43,139
 décaler que retour en mode d'exécution et je vais 

155
00:06:40,139 --> 00:06:46,019
 zoomer ici pour que vous puissiez voir ce qui est 

156
00:06:43,019 --> 00:06:49,230
 aller et obtenir ceci ici, je pense que vous 

157
00:06:46,230 --> 00:06:52,139
 peut tout voir là - bas et maintenant nous 

158
00:06:49,139 --> 00:06:59,529
 peut réinitialiser l'ordinateur et essayer de courir 

159
00:06:52,529 --> 00:07:02,870
 cela et il semble que cela fonctionne 

160
00:06:59,870 --> 00:07:06,190
 ouais on y va ça compte à travers 

161
00:07:02,190 --> 00:07:08,990
 tous les chiffres de Fibonacci et il semble 

162
00:07:06,990 --> 00:07:10,190
 comme il pourrait y avoir un bug, il ressemble 

163
00:07:08,190 --> 00:07:12,440
 il manque le dernier 233 donc 

164
00:07:10,440 --> 00:07:13,149
 il y a probablement un petit bug 

165
00:07:12,149 --> 00:07:16,920
 avec la logique de saut 

166
00:07:13,920 --> 00:07:21,920
 peut-être que je suis oh oui parce que je sors 

167
00:07:16,920 --> 00:07:22,509
 d'abord, puis en ajoutant bien peut-être bien 

168
00:07:21,509 --> 00:07:24,860
 Je vais résoudre ce problème un peu plus tard, mais 

169
00:07:22,860 --> 00:07:27,870
 assez proche, nous obtenons Fibonacci 

170
00:07:24,870 --> 00:07:27,000
 Nombres 
Subtitles End: mo.dbxdb.com

